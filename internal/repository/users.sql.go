// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (user_id, doctor_id, availability_id, booking_date, booking_start_time, booking_end_time, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, doctor_id, availability_id, booking_date, booking_start_time, booking_end_time, status, created_at, updated_at
`

type CreateBookingParams struct {
	UserID           pgtype.UUID
	DoctorID         pgtype.UUID
	AvailabilityID   pgtype.UUID
	BookingDate      pgtype.Date
	BookingStartTime pgtype.Time
	BookingEndTime   pgtype.Time
	Status           string
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.UserID,
		arg.DoctorID,
		arg.AvailabilityID,
		arg.BookingDate,
		arg.BookingStartTime,
		arg.BookingEndTime,
		arg.Status,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DoctorID,
		&i.AvailabilityID,
		&i.BookingDate,
		&i.BookingStartTime,
		&i.BookingEndTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDoctor = `-- name: CreateDoctor :one
INSERT INTO doctors (
    name,
    specialization,
    experience,
    qualification,
    hospital_name,
    consultation_fee,
    contact_number,
    email,
    password_hash
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, name, specialization, experience, qualification, hospital_name, consultation_fee, contact_number, email, created_at, updated_at
`

type CreateDoctorParams struct {
	Name            string
	Specialization  string
	Experience      int32
	Qualification   string
	HospitalName    string
	ConsultationFee pgtype.Numeric
	ContactNumber   *string
	Email           *string
	PasswordHash    *string
}

type CreateDoctorRow struct {
	ID              pgtype.UUID
	Name            string
	Specialization  string
	Experience      int32
	Qualification   string
	HospitalName    string
	ConsultationFee pgtype.Numeric
	ContactNumber   *string
	Email           *string
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (CreateDoctorRow, error) {
	row := q.db.QueryRow(ctx, createDoctor,
		arg.Name,
		arg.Specialization,
		arg.Experience,
		arg.Qualification,
		arg.HospitalName,
		arg.ConsultationFee,
		arg.ContactNumber,
		arg.Email,
		arg.PasswordHash,
	)
	var i CreateDoctorRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Specialization,
		&i.Experience,
		&i.Qualification,
		&i.HospitalName,
		&i.ConsultationFee,
		&i.ContactNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDoctorAvailability = `-- name: CreateDoctorAvailability :one
INSERT INTO doctor_availability (doctor_id, availability_date, start_time, end_time)
VALUES ($1, $2, $3, $4)
RETURNING id, doctor_id, availability_date, start_time, end_time, is_booked, created_at, updated_at
`

type CreateDoctorAvailabilityParams struct {
	DoctorID         pgtype.UUID
	AvailabilityDate pgtype.Date
	StartTime        pgtype.Time
	EndTime          pgtype.Time
}

func (q *Queries) CreateDoctorAvailability(ctx context.Context, arg CreateDoctorAvailabilityParams) (DoctorAvailability, error) {
	row := q.db.QueryRow(ctx, createDoctorAvailability,
		arg.DoctorID,
		arg.AvailabilityDate,
		arg.StartTime,
		arg.EndTime,
	)
	var i DoctorAvailability
	err := row.Scan(
		&i.ID,
		&i.DoctorID,
		&i.AvailabilityDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsBooked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMedication = `-- name: CreateMedication :one
INSERT INTO medications (user_id, medication_name, dosage, time_to_notify, frequency)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, medication_name, dosage, time_to_notify, frequency, is_readbyuser, created_at, updated_at
`

type CreateMedicationParams struct {
	UserID         pgtype.UUID
	MedicationName string
	Dosage         string
	TimeToNotify   pgtype.Time
	Frequency      string
}

func (q *Queries) CreateMedication(ctx context.Context, arg CreateMedicationParams) (Medication, error) {
	row := q.db.QueryRow(ctx, createMedication,
		arg.UserID,
		arg.MedicationName,
		arg.Dosage,
		arg.TimeToNotify,
		arg.Frequency,
	)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MedicationName,
		&i.Dosage,
		&i.TimeToNotify,
		&i.Frequency,
		&i.IsReadbyuser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithEmail = `-- name: CreateUserWithEmail :one
INSERT INTO users (email, password_hash, name)
VALUES ($1, $2, $3)
RETURNING id, email, name, created_at, updated_at
`

type CreateUserWithEmailParams struct {
	Email        string
	PasswordHash *string
	Name         *string
}

type CreateUserWithEmailRow struct {
	ID        pgtype.UUID
	Email     string
	Name      *string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) CreateUserWithEmail(ctx context.Context, arg CreateUserWithEmailParams) (CreateUserWithEmailRow, error) {
	row := q.db.QueryRow(ctx, createUserWithEmail, arg.Email, arg.PasswordHash, arg.Name)
	var i CreateUserWithEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithGoogle = `-- name: CreateUserWithGoogle :one
INSERT INTO users (google_id, email, name)
VALUES ($1, $2, $3)
RETURNING id, email, google_id, name
`

type CreateUserWithGoogleParams struct {
	GoogleID *string
	Email    string
	Name     *string
}

type CreateUserWithGoogleRow struct {
	ID       pgtype.UUID
	Email    string
	GoogleID *string
	Name     *string
}

func (q *Queries) CreateUserWithGoogle(ctx context.Context, arg CreateUserWithGoogleParams) (CreateUserWithGoogleRow, error) {
	row := q.db.QueryRow(ctx, createUserWithGoogle, arg.GoogleID, arg.Email, arg.Name)
	var i CreateUserWithGoogleRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.GoogleID,
		&i.Name,
	)
	return i, err
}

const deleteBooking = `-- name: DeleteBooking :exec
DELETE FROM bookings
WHERE id = $1
`

func (q *Queries) DeleteBooking(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBooking, id)
	return err
}

const deleteDoctorAvailability = `-- name: DeleteDoctorAvailability :exec
DELETE FROM doctor_availability
WHERE id = $1 AND doctor_id = $2
`

type DeleteDoctorAvailabilityParams struct {
	ID       pgtype.UUID
	DoctorID pgtype.UUID
}

func (q *Queries) DeleteDoctorAvailability(ctx context.Context, arg DeleteDoctorAvailabilityParams) error {
	_, err := q.db.Exec(ctx, deleteDoctorAvailability, arg.ID, arg.DoctorID)
	return err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT id, user_id, doctor_id, availability_id, booking_date, booking_start_time, booking_end_time, status, created_at, updated_at
FROM bookings
WHERE id = $1
`

func (q *Queries) GetBookingByID(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByID, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DoctorID,
		&i.AvailabilityID,
		&i.BookingDate,
		&i.BookingStartTime,
		&i.BookingEndTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingsByAvailabilityID = `-- name: GetBookingsByAvailabilityID :many
SELECT id, user_id, doctor_id, availability_id, booking_date, booking_start_time, booking_end_time, status, created_at, updated_at
FROM bookings
WHERE availability_id = $1
`

func (q *Queries) GetBookingsByAvailabilityID(ctx context.Context, availabilityID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getBookingsByAvailabilityID, availabilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DoctorID,
			&i.AvailabilityID,
			&i.BookingDate,
			&i.BookingStartTime,
			&i.BookingEndTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsByDoctorID = `-- name: GetBookingsByDoctorID :many
SELECT id, user_id, doctor_id, availability_id, booking_date, booking_start_time, booking_end_time, status, created_at, updated_at
FROM bookings
WHERE doctor_id = $1
`

func (q *Queries) GetBookingsByDoctorID(ctx context.Context, doctorID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getBookingsByDoctorID, doctorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DoctorID,
			&i.AvailabilityID,
			&i.BookingDate,
			&i.BookingStartTime,
			&i.BookingEndTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsByUserID = `-- name: GetBookingsByUserID :many
SELECT id, user_id, doctor_id, availability_id, booking_date, booking_start_time, booking_end_time, status, created_at, updated_at
FROM bookings
WHERE user_id = $1
`

func (q *Queries) GetBookingsByUserID(ctx context.Context, userID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getBookingsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DoctorID,
			&i.AvailabilityID,
			&i.BookingDate,
			&i.BookingStartTime,
			&i.BookingEndTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoctorAvailabilityByDoctor = `-- name: GetDoctorAvailabilityByDoctor :many
SELECT id, doctor_id, availability_date, start_time, end_time, is_booked, created_at, updated_at
FROM doctor_availability
WHERE doctor_id = $1
`

func (q *Queries) GetDoctorAvailabilityByDoctor(ctx context.Context, doctorID pgtype.UUID) ([]DoctorAvailability, error) {
	rows, err := q.db.Query(ctx, getDoctorAvailabilityByDoctor, doctorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DoctorAvailability
	for rows.Next() {
		var i DoctorAvailability
		if err := rows.Scan(
			&i.ID,
			&i.DoctorID,
			&i.AvailabilityDate,
			&i.StartTime,
			&i.EndTime,
			&i.IsBooked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoctorAvailabilityByDoctorAndDate = `-- name: GetDoctorAvailabilityByDoctorAndDate :many
SELECT id, doctor_id, availability_date, start_time, end_time, is_booked, created_at, updated_at
FROM doctor_availability
WHERE doctor_id = $1 AND availability_date = $2
`

type GetDoctorAvailabilityByDoctorAndDateParams struct {
	DoctorID         pgtype.UUID
	AvailabilityDate pgtype.Date
}

func (q *Queries) GetDoctorAvailabilityByDoctorAndDate(ctx context.Context, arg GetDoctorAvailabilityByDoctorAndDateParams) ([]DoctorAvailability, error) {
	rows, err := q.db.Query(ctx, getDoctorAvailabilityByDoctorAndDate, arg.DoctorID, arg.AvailabilityDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DoctorAvailability
	for rows.Next() {
		var i DoctorAvailability
		if err := rows.Scan(
			&i.ID,
			&i.DoctorID,
			&i.AvailabilityDate,
			&i.StartTime,
			&i.EndTime,
			&i.IsBooked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoctorAvailabilityByID = `-- name: GetDoctorAvailabilityByID :one
SELECT id, doctor_id, availability_date, start_time, end_time, is_booked, created_at, updated_at
FROM doctor_availability
WHERE id = $1
`

func (q *Queries) GetDoctorAvailabilityByID(ctx context.Context, id pgtype.UUID) (DoctorAvailability, error) {
	row := q.db.QueryRow(ctx, getDoctorAvailabilityByID, id)
	var i DoctorAvailability
	err := row.Scan(
		&i.ID,
		&i.DoctorID,
		&i.AvailabilityDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsBooked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctorByEmail = `-- name: GetDoctorByEmail :one
SELECT id, name, specialization, experience, qualification, hospital_name, consultation_fee, contact_number, email, password_hash, created_at, updated_at
FROM doctors
WHERE email = $1
`

type GetDoctorByEmailRow struct {
	ID              pgtype.UUID
	Name            string
	Specialization  string
	Experience      int32
	Qualification   string
	HospitalName    string
	ConsultationFee pgtype.Numeric
	ContactNumber   *string
	Email           *string
	PasswordHash    *string
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) GetDoctorByEmail(ctx context.Context, email *string) (GetDoctorByEmailRow, error) {
	row := q.db.QueryRow(ctx, getDoctorByEmail, email)
	var i GetDoctorByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Specialization,
		&i.Experience,
		&i.Qualification,
		&i.HospitalName,
		&i.ConsultationFee,
		&i.ContactNumber,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctorByID = `-- name: GetDoctorByID :one
SELECT id, name, password_hash, specialization, experience, qualification, hospital_name, consultation_fee, contact_number, email, created_at, updated_at
FROM doctors
WHERE id = $1
`

func (q *Queries) GetDoctorByID(ctx context.Context, id pgtype.UUID) (Doctor, error) {
	row := q.db.QueryRow(ctx, getDoctorByID, id)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Specialization,
		&i.Experience,
		&i.Qualification,
		&i.HospitalName,
		&i.ConsultationFee,
		&i.ContactNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEncryptedFile = `-- name: GetEncryptedFile :one
SELECT file_name, file_data FROM encrypted_files WHERE user_id = $1 AND id = $2
`

type GetEncryptedFileParams struct {
	UserID pgtype.UUID
	ID     pgtype.UUID
}

type GetEncryptedFileRow struct {
	FileName string
	FileData []byte
}

func (q *Queries) GetEncryptedFile(ctx context.Context, arg GetEncryptedFileParams) (GetEncryptedFileRow, error) {
	row := q.db.QueryRow(ctx, getEncryptedFile, arg.UserID, arg.ID)
	var i GetEncryptedFileRow
	err := row.Scan(&i.FileName, &i.FileData)
	return i, err
}

const getMedicationsByUserID = `-- name: GetMedicationsByUserID :many
SELECT
    id,
    user_id,
    medication_name,
    dosage,
    time_to_notify,
    frequency,
    is_readbyuser,
    created_at,
    updated_at
FROM
    medications
WHERE
    user_id = $1
`

func (q *Queries) GetMedicationsByUserID(ctx context.Context, userID pgtype.UUID) ([]Medication, error) {
	rows, err := q.db.Query(ctx, getMedicationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medication
	for rows.Next() {
		var i Medication
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MedicationName,
			&i.Dosage,
			&i.TimeToNotify,
			&i.Frequency,
			&i.IsReadbyuser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationsToNotify = `-- name: GetMedicationsToNotify :many
SELECT id, user_id, medication_name, dosage, time_to_notify, frequency, is_readbyuser, created_at, updated_at
FROM medications
WHERE time_to_notify = $1
  AND (frequency = 'daily' OR (frequency = 'weekly' AND EXTRACT(DOW FROM NOW()) = EXTRACT(DOW FROM updated_at)))
`

func (q *Queries) GetMedicationsToNotify(ctx context.Context, timeToNotify pgtype.Time) ([]Medication, error) {
	rows, err := q.db.Query(ctx, getMedicationsToNotify, timeToNotify)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medication
	for rows.Next() {
		var i Medication
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MedicationName,
			&i.Dosage,
			&i.TimeToNotify,
			&i.Frequency,
			&i.IsReadbyuser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, google_id, name, created_at, updated_at
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID           pgtype.UUID
	Email        string
	PasswordHash *string
	GoogleID     *string
	Name         *string
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.GoogleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, email, google_id, name, created_at, updated_at
FROM users
WHERE google_id = $1
`

type GetUserByGoogleIDRow struct {
	ID        pgtype.UUID
	Email     string
	GoogleID  *string
	Name      *string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID *string) (GetUserByGoogleIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i GetUserByGoogleIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.GoogleID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
select id, email, name, age, gender, blood_group, emergency_contact_number, emergency_contact_relationship, updated_at 
FROM users 
WHERE id = $1
`

type GetUserByIDRow struct {
	ID                           pgtype.UUID
	Email                        string
	Name                         *string
	Age                          *int32
	Gender                       *string
	BloodGroup                   *string
	EmergencyContactNumber       *string
	EmergencyContactRelationship *string
	UpdatedAt                    pgtype.Timestamp
}

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Age,
		&i.Gender,
		&i.BloodGroup,
		&i.EmergencyContactNumber,
		&i.EmergencyContactRelationship,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserFCMToken = `-- name: GetUserFCMToken :one
SELECT fcm_token
FROM users
WHERE id = $1
`

func (q *Queries) GetUserFCMToken(ctx context.Context, id pgtype.UUID) (*string, error) {
	row := q.db.QueryRow(ctx, getUserFCMToken, id)
	var fcm_token *string
	err := row.Scan(&fcm_token)
	return fcm_token, err
}

const getUserFiles = `-- name: GetUserFiles :many
SELECT id, user_id, file_name, file_data, created_at
FROM encrypted_files 
WHERE user_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetUserFiles(ctx context.Context, userID pgtype.UUID) ([]EncryptedFile, error) {
	rows, err := q.db.Query(ctx, getUserFiles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EncryptedFile
	for rows.Next() {
		var i EncryptedFile
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileName,
			&i.FileData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProfileByID = `-- name: GetUserProfileByID :one
SELECT id, email, password_hash, fcm_token, google_id, name, age, gender, blood_group, emergency_contact_number, emergency_contact_relationship, created_at, updated_at
FROM users
WHERE id = $1
`

func (q *Queries) GetUserProfileByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserProfileByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FcmToken,
		&i.GoogleID,
		&i.Name,
		&i.Age,
		&i.Gender,
		&i.BloodGroup,
		&i.EmergencyContactNumber,
		&i.EmergencyContactRelationship,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDoctors = `-- name: ListDoctors :many
SELECT id, name, password_hash, specialization, experience, qualification, hospital_name, consultation_fee, contact_number, email, created_at, updated_at
FROM doctors
`

func (q *Queries) ListDoctors(ctx context.Context) ([]Doctor, error) {
	rows, err := q.db.Query(ctx, listDoctors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Doctor
	for rows.Next() {
		var i Doctor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PasswordHash,
			&i.Specialization,
			&i.Experience,
			&i.Qualification,
			&i.HospitalName,
			&i.ConsultationFee,
			&i.ContactNumber,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeEncryptedFile = `-- name: StoreEncryptedFile :one
INSERT INTO encrypted_files (user_id, file_name, file_data)
VALUES ($1, $2, $3)
RETURNING id, created_at
`

type StoreEncryptedFileParams struct {
	UserID   pgtype.UUID
	FileName string
	FileData []byte
}

type StoreEncryptedFileRow struct {
	ID        pgtype.UUID
	CreatedAt pgtype.Timestamp
}

func (q *Queries) StoreEncryptedFile(ctx context.Context, arg StoreEncryptedFileParams) (StoreEncryptedFileRow, error) {
	row := q.db.QueryRow(ctx, storeEncryptedFile, arg.UserID, arg.FileName, arg.FileData)
	var i StoreEncryptedFileRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const updateAvailabilityBookedStatus = `-- name: UpdateAvailabilityBookedStatus :exec
UPDATE doctor_availability
SET
    is_booked = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateAvailabilityBookedStatusParams struct {
	IsBooked *bool
	ID       pgtype.UUID
}

func (q *Queries) UpdateAvailabilityBookedStatus(ctx context.Context, arg UpdateAvailabilityBookedStatusParams) error {
	_, err := q.db.Exec(ctx, updateAvailabilityBookedStatus, arg.IsBooked, arg.ID)
	return err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :exec
UPDATE bookings
SET
    status = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateBookingStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) error {
	_, err := q.db.Exec(ctx, updateBookingStatus, arg.Status, arg.ID)
	return err
}

const updateDoctorAvailability = `-- name: UpdateDoctorAvailability :exec
UPDATE doctor_availability
SET
    start_time = COALESCE($1, start_time),
    end_time = COALESCE($2, end_time),
    is_booked = COALESCE($3, is_booked),
    updated_at = NOW()
WHERE id = $4 AND doctor_id = $5
`

type UpdateDoctorAvailabilityParams struct {
	StartTime pgtype.Time
	EndTime   pgtype.Time
	IsBooked  *bool
	ID        pgtype.UUID
	DoctorID  pgtype.UUID
}

func (q *Queries) UpdateDoctorAvailability(ctx context.Context, arg UpdateDoctorAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateDoctorAvailability,
		arg.StartTime,
		arg.EndTime,
		arg.IsBooked,
		arg.ID,
		arg.DoctorID,
	)
	return err
}

const updateMedicationReadStatus = `-- name: UpdateMedicationReadStatus :exec
UPDATE medications
SET is_readbyuser = TRUE
WHERE id = $1
`

func (q *Queries) UpdateMedicationReadStatus(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateMedicationReadStatus, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2, updated_at = NOW()
WHERE email = $1
`

type UpdateUserPasswordParams struct {
	Email        string
	PasswordHash *string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.Email, arg.PasswordHash)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users
SET 
    name = COALESCE($1, name),
    age = COALESCE($2, age),
    gender = COALESCE($3, gender),
    blood_group = COALESCE($4, blood_group),
    emergency_contact_number = COALESCE($5, emergency_contact_number),
    emergency_contact_relationship = COALESCE($6, emergency_contact_relationship),
    updated_at = NOW()
WHERE id = $7
`

type UpdateUserProfileParams struct {
	Name                         *string
	Age                          *int32
	Gender                       *string
	BloodGroup                   *string
	EmergencyContactNumber       *string
	EmergencyContactRelationship *string
	ID                           pgtype.UUID
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile,
		arg.Name,
		arg.Age,
		arg.Gender,
		arg.BloodGroup,
		arg.EmergencyContactNumber,
		arg.EmergencyContactRelationship,
		arg.ID,
	)
	return err
}
